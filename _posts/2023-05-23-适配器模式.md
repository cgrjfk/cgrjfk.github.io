---
layout:     post
title:      适配器模式
subtitle:   Java
date:       2023-05-23
author:     Rui
header-img: img/post-bg-map.jpg
catalog: true
tags:
    - 结构型模式
---
### 前言
最近我在学设计模式，我打算用博客的形式来记录我的学习过程，这是适配器模式。
### 简介
适配器模式是一种结构型设计模式，它允许将一个类的接口转换为客户端所期望的另一个接口。适配器模式可以使不兼容的接口能够一起工作，从而促进了现有类的重用。
### 正文
适配器模式涉及三个主要角色：

1. **目标接口（Target Interface）**：目标接口是客户端所期望的接口，它定义了客户端使用的方法和功能。客户端通过目标接口与适配器进行交互。

2. **适配器（Adapter）**：适配器是一个实现了目标接口的类。它包装了一个已有的类或接口，使其能够与目标接口兼容。适配器通过调用被适配对象的方法来实现目标接口的功能，并进行必要的转换以满足目标接口的要求。

3. **被适配对象（Adaptee）**：被适配对象是已经存在的类或接口，它需要被适配以满足目标接口的要求。被适配对象具有一些功能和方法，但与目标接口不兼容。

适配器模式可以根据实现方式和适配对象的不同，分为以下几种类型：

1. **类适配器（Class Adapter）**：类适配器使用继承的方式将适配器类与被适配类进行连接。适配器类继承了被适配类，并实现了目标接口。通过继承关系，适配器类可以重写被适配类的方法，并在其中进行适配操作。

2. **对象适配器（Object Adapter）**：对象适配器使用组合的方式将适配器类与被适配类进行连接。适配器类持有一个被适配类的对象实例，并实现了目标接口。通过组合关系，适配器类可以调用被适配类的方法，并在其中进行适配操作。

3. **接口适配器（Interface Adapter）**：接口适配器也被称为默认适配器或空适配器。它通过一个抽象适配器类作为中间层，将目标接口与多个不同的被适配类进行连接。适配器类实现了目标接口，并提供了默认的空方法实现。这样，客户端可以根据需要选择性地重写适配器类中的方法，从而实现自己所需的适配功能。

每种适配器类型都有其特定的使用场景和适用性。类适配器和对象适配器是常见的适配器模式实现方式，它们在设计和实现上略有不同。接口适配器则更加灵活，可以根据需要选择性地实现适配器中的方法。由于类适配器的耦合度比对象适配器高，如果类适配器和对象适配器可以二选一的话，最好选择对象适配器。

适配器模式的工作流程如下：

1. 客户端通过调用目标接口的方法来发起请求。
2. 适配器接收到请求后，将其转发给被适配对象。
3. 被适配对象执行请求，并返回结果给适配器。
4. 适配器将结果转换为目标接口的格式，并将结果返回给客户端。

适配器模式的优点包括：

- 代码复用和灵活性：适配器模式可以重用已有的类或接口，而无需修改其原始代码。它提供了一种灵活的方式来使不兼容的类能够一起工作。
- 支持接口间的解耦：适配器模式可以将客户端与被适配对象的实现细节解耦，使得它们可以独立进行修改和演化。
- 提高系统的可扩展性和可维护性：通过适配器模式，可以方便地添加新的适配器来支持新的类或接口，从而提高系统的可扩展性和可维护性。

适配器模式一些限制和注意事项：

- 在设计初期应尽量避免使用适配器模式，而是优先考虑使用兼容的接口设计。
- 适配器模式增加了一层间接性，可能会导致系统复杂性增加。
- 在选择类适配器还是对象适配器时需要根据具体情况进行权衡，对象适配器更灵活，但类适配器可以重写被适配者的方法。

适配器模式常见的应用场景包括：

- 将旧版接口适配为新版接口：当系统升级或演进时，可能需要将旧版的接口适配为新版的接口，以兼容已有的代码。
- 将第三方库或组件的接口适配为应用程序需要的接口：当使用第三方库或组件时，其提供的接口可能与应用程序需要的接口不一致，此时可以使用适配器模式进行适配。
- 在系统演进或重构过程中，用于兼容不同接口或模块之间的变化：当系统中的不同模块或组件之间接口发生变化时，可以使用适配器模式来兼容这些变化。

### 代码示例
```java
//对象适配器Java示例
// 目标接口
interface Target {
    void request();
}

// 被适配类
class Adaptee {
    public void specificRequest() {
        System.out.println("Adaptee's specific request");
    }
}

// 对象适配器类
class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.specificRequest();
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        // 创建被适配对象
        Adaptee adaptee = new Adaptee();

        // 创建适配器对象并传入被适配对象
        Target adapter = new Adapter(adaptee);

        // 调用目标接口的方法，实际上会调用被适配对象的方法
        adapter.request();
    }
}
//运行结果:
//Adaptee's specific request

```
### UML图
![Adapter-patten.png](https://i.postimg.cc/bYxCztfW/Adapter-patten.png)
### 分析
我们创建了一个被适配类 Adaptee，它有一个 specificRequest 方法表示其特定行为。然后我们定义了一个目标接口 Target，其中包含一个 request 方法。接下来，我们创建了一个对象适配器类 Adapter，它实现了 Target 接口，并在其内部持有一个 Adaptee 对象。在 Adapter 的 request 方法中，实际上调用了 Adaptee 的 specificRequest 方法，完成了适配。最后，在客户端代码中，我们创建了被适配对象 Adaptee 和适配器对象 Adapter，并通过调用适配器的 request 方法来实现对被适配对象的调用。
### 总结
总而言之，适配器模式是一种解决接口不兼容性的设计模式，它能够在现有系统中引入新的代码而不破坏原有代码结构，提供了一种平滑过渡的方式。通过适配器模式，不同接口的类可以协同工作，提高了代码的灵活性和可复用性。


